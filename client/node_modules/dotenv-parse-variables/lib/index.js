"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const isSANB = require('is-string-and-not-blank');

const debug = require('debug')('dotenv-parse-variables');

const DEFAULT_OPTIONS = {
  assignToProcessEnv: true,
  overrideProcessEnv: false,
  ignoreFunctions: true
};

module.exports = (env, options) => {
  const envOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options || {});

  const parsed = {};

  for (const key of Object.keys(env)) {
    debug(`key "${key}" before type was ${typeof env[key]}`);

    if (envOptions.ignoreFunctions && typeof env[key] === 'function') {
      debug(`key "${key}" was a function so it is being ignored due to ignoreFunctions: true`);
      continue;
    }

    parsed[key] = parseKey(env[key], key);
    debug(`key "${key}" after type was ${typeof parsed[key]}`);

    if (envOptions.assignToProcessEnv === true) {
      if (envOptions.overrideProcessEnv === true) {
        process.env[key] = parsed[key] || process.env[key];
      } else {
        process.env[key] = process.env[key] || parsed[key];
      }
    }
  }

  return parsed;
};

function parseKey(value, key) {
  debug(`parsing key ${key} with value ${value}`); // if the value is wrapped in bacticks e.g. (`value`) then just return its value

  if (value.toString().indexOf('`') === 0 && value.toString().lastIndexOf('`') === value.toString().length - 1) {
    debug(`key ${key} is wrapped in bacticks and will be ignored from parsing`);
    return value.toString().slice(1, value.toString().length - 1);
  } // if the value ends in an asterisk then just return its value


  if (value.toString().lastIndexOf('*') === value.toString().length - 1 && !value.toString().includes(',')) {
    debug(`key ${key} ended in * and will be ignored from parsing`);
    return value.toString().slice(0, Math.max(0, value.toString().length - 1));
  } // Boolean


  if (value.toString().toLowerCase() === 'true' || value.toString().toLowerCase() === 'false') {
    debug(`key ${key} parsed as a Boolean`);
    return value.toString().toLowerCase() === 'true';
  } // Number


  if (isSANB(value) && !Number.isNaN(Number(value))) {
    debug(`key ${key} parsed as a Number`);
    return Number(value);
  } // Array


  if ((Array.isArray(value) || typeof value === 'string') && typeof value.includes === 'function' && value.includes(',')) {
    debug(`key ${key} parsed as an Array`);
    return value.split(',').filter(string => {
      return string !== '';
    }).map(string => parseKey(string));
  }

  return value;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJpc1NBTkIiLCJyZXF1aXJlIiwiZGVidWciLCJERUZBVUxUX09QVElPTlMiLCJhc3NpZ25Ub1Byb2Nlc3NFbnYiLCJvdmVycmlkZVByb2Nlc3NFbnYiLCJpZ25vcmVGdW5jdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZW52Iiwib3B0aW9ucyIsImVudk9wdGlvbnMiLCJwYXJzZWQiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwicGFyc2VLZXkiLCJwcm9jZXNzIiwidmFsdWUiLCJ0b1N0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImxlbmd0aCIsInNsaWNlIiwiaW5jbHVkZXMiLCJNYXRoIiwibWF4IiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJpc05hTiIsIkFycmF5IiwiaXNBcnJheSIsInNwbGl0IiwiZmlsdGVyIiwic3RyaW5nIiwibWFwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLHlCQUFELENBQXRCOztBQUNBLE1BQU1DLEtBQUssR0FBR0QsT0FBTyxDQUFDLE9BQUQsQ0FBUCxDQUFpQix3QkFBakIsQ0FBZDs7QUFFQSxNQUFNRSxlQUFlLEdBQUc7QUFDdEJDLEVBQUFBLGtCQUFrQixFQUFFLElBREU7QUFFdEJDLEVBQUFBLGtCQUFrQixFQUFFLEtBRkU7QUFHdEJDLEVBQUFBLGVBQWUsRUFBRTtBQUhLLENBQXhCOztBQU1BQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEtBQWtCO0FBQ2pDLFFBQU1DLFVBQVUsbUNBQVFSLGVBQVIsR0FBNkJPLE9BQU8sSUFBSSxFQUF4QyxDQUFoQjs7QUFFQSxRQUFNRSxNQUFNLEdBQUcsRUFBZjs7QUFFQSxPQUFLLE1BQU1DLEdBQVgsSUFBa0JDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTixHQUFaLENBQWxCLEVBQW9DO0FBQ2xDUCxJQUFBQSxLQUFLLENBQUUsUUFB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Q0FBQ1UsTUFBTSxDQUFDQyxLQUFQLENBQWFELE1BQU0sQ0FBQ1YsS0FBRCxDQUFuQixDQUF0QixFQUFtRDtBQUNqRGhCLElBQUFBLEtBQUssQ0FBRSxPQUFNVyxHQUFJLHFCQUFaLENBQUw7QUFDQSxXQUFPZSxNQUFNLENBQUNWLEtBQUQsQ0FBYjtBQUNELEdBbEMyQixDQW9DNUI7OztBQUNBLE1BQ0UsQ0FBQ1ksS0FBSyxDQUFDQyxPQUFOLENBQWNiLEtBQWQsS0FBd0IsT0FBT0EsS0FBUCxLQUFpQixRQUExQyxLQUNBLE9BQU9BLEtBQUssQ0FBQ00sUUFBYixLQUEwQixVQUQxQixJQUVBTixLQUFLLENBQUNNLFFBQU4sQ0FBZSxHQUFmLENBSEYsRUFJRTtBQUNBdEIsSUFBQUEsS0FBSyxDQUFFLE9BQU1XLEdBQUkscUJBQVosQ0FBTDtBQUNBLFdBQU9LLEtBQUssQ0FDVGMsS0FESSxDQUNFLEdBREYsRUFFSkMsTUFGSSxDQUVJQyxNQUFELElBQVk7QUFDbEIsYUFBT0EsTUFBTSxLQUFLLEVBQWxCO0FBQ0QsS0FKSSxFQUtKQyxHQUxJLENBS0NELE1BQUQsSUFBWWxCLFFBQVEsQ0FBQ2tCLE1BQUQsQ0FMcEIsQ0FBUDtBQU1EOztBQUVELFNBQU9oQixLQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1NBTkIgPSByZXF1aXJlKCdpcy1zdHJpbmctYW5kLW5vdC1ibGFuaycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdkb3RlbnYtcGFyc2UtdmFyaWFibGVzJyk7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgYXNzaWduVG9Qcm9jZXNzRW52OiB0cnVlLFxuICBvdmVycmlkZVByb2Nlc3NFbnY6IGZhbHNlLFxuICBpZ25vcmVGdW5jdGlvbnM6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGVudiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlbnZPcHRpb25zID0geyAuLi5ERUZBVUxUX09QVElPTlMsIC4uLihvcHRpb25zIHx8IHt9KSB9O1xuXG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVudikpIHtcbiAgICBkZWJ1Zyhga2V5IFwiJHtrZXl9XCIgYmVmb3JlIHR5cGUgd2FzICR7dHlwZW9mIGVudltrZXldfWApO1xuICAgIGlmIChlbnZPcHRpb25zLmlnbm9yZUZ1bmN0aW9ucyAmJiB0eXBlb2YgZW52W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICBga2V5IFwiJHtrZXl9XCIgd2FzIGEgZnVuY3Rpb24gc28gaXQgaXMgYmVpbmcgaWdub3JlZCBkdWUgdG8gaWdub3JlRnVuY3Rpb25zOiB0cnVlYFxuICAgICAgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlZFtrZXldID0gcGFyc2VLZXkoZW52W2tleV0sIGtleSk7XG4gICAgZGVidWcoYGtleSBcIiR7a2V5fVwiIGFmdGVyIHR5cGUgd2FzICR7dHlwZW9mIHBhcnNlZFtrZXldfWApO1xuICAgIGlmIChlbnZPcHRpb25zLmFzc2lnblRvUHJvY2Vzc0VudiA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKGVudk9wdGlvbnMub3ZlcnJpZGVQcm9jZXNzRW52ID09PSB0cnVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52W2tleV0gPSBwYXJzZWRba2V5XSB8fCBwcm9jZXNzLmVudltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnZba2V5XSA9IHByb2Nlc3MuZW52W2tleV0gfHwgcGFyc2VkW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlS2V5KHZhbHVlLCBrZXkpIHtcbiAgZGVidWcoYHBhcnNpbmcga2V5ICR7a2V5fSB3aXRoIHZhbHVlICR7dmFsdWV9YCk7XG5cbiAgLy8gaWYgdGhlIHZhbHVlIGlzIHdyYXBwZWQgaW4gYmFjdGlja3MgZS5nLiAoYHZhbHVlYCkgdGhlbiBqdXN0IHJldHVybiBpdHMgdmFsdWVcbiAgaWYgKFxuICAgIHZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZignYCcpID09PSAwICYmXG4gICAgdmFsdWUudG9TdHJpbmcoKS5sYXN0SW5kZXhPZignYCcpID09PSB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCAtIDFcbiAgKSB7XG4gICAgZGVidWcoYGtleSAke2tleX0gaXMgd3JhcHBlZCBpbiBiYWN0aWNrcyBhbmQgd2lsbCBiZSBpZ25vcmVkIGZyb20gcGFyc2luZ2ApO1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLnNsaWNlKDEsIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBpZiB0aGUgdmFsdWUgZW5kcyBpbiBhbiBhc3RlcmlzayB0aGVuIGp1c3QgcmV0dXJuIGl0cyB2YWx1ZVxuICBpZiAoXG4gICAgdmFsdWUudG9TdHJpbmcoKS5sYXN0SW5kZXhPZignKicpID09PSB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCAtIDEgJiZcbiAgICAhdmFsdWUudG9TdHJpbmcoKS5pbmNsdWRlcygnLCcpXG4gICkge1xuICAgIGRlYnVnKGBrZXkgJHtrZXl9IGVuZGVkIGluICogYW5kIHdpbGwgYmUgaWdub3JlZCBmcm9tIHBhcnNpbmdgKTtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5zbGljZSgwLCBNYXRoLm1heCgwLCB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCAtIDEpKTtcbiAgfVxuXG4gIC8vIEJvb2xlYW5cbiAgaWYgKFxuICAgIHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnIHx8XG4gICAgdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnXG4gICkge1xuICAgIGRlYnVnKGBrZXkgJHtrZXl9IHBhcnNlZCBhcyBhIEJvb2xlYW5gKTtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gIH1cblxuICAvLyBOdW1iZXJcbiAgaWYgKGlzU0FOQih2YWx1ZSkgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKSkge1xuICAgIGRlYnVnKGBrZXkgJHtrZXl9IHBhcnNlZCBhcyBhIE51bWJlcmApO1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gQXJyYXlcbiAgaWYgKFxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSAmJlxuICAgIHR5cGVvZiB2YWx1ZS5pbmNsdWRlcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHZhbHVlLmluY2x1ZGVzKCcsJylcbiAgKSB7XG4gICAgZGVidWcoYGtleSAke2tleX0gcGFyc2VkIGFzIGFuIEFycmF5YCk7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAuc3BsaXQoJywnKVxuICAgICAgLmZpbHRlcigoc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJpbmcgIT09ICcnO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKHN0cmluZykgPT4gcGFyc2VLZXkoc3RyaW5nKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4iXX0=